Interface to the HYPRE library

top level table hypre contains all bindings

hypre.matrix.Dummy {L=lattice, m=v } -- create a dummy matrix (real laplacian)
hypre.matrix.Wilson { ... } -- create the Wilson matrix
hypre.matrix.Clover { ... } -- create the Clover matrix

hypre.solver.* {}           -- create a solver (just remember the parameters)

====================
for Dummy:

type(M)                     -- string of the type, e.g. "hypre.matrix.Laplacian(d)"
M.lattice                   -- lattice of M
V = M:vector(f)             -- inject L:Real() into hypre
V = M * V                   -- apply matrix to a vector
V = M(V)                    -- ditto
V = V * a                   -- scale vector
V = a * V                   -- ditto
V = V / a                   -- ditto
V = -V                      -- opposite vector
V = V + V                   -- add two vectors
V = V - V                   -- substract two vectors
s = type(V)                 -- "hypre.vector.real(d)"
M = V.matrix                -- matrix of the vector
f = V:value()               -- convert vector back to the Qlua land
a = V:norm2()               -- norm of the vector
a = dot(V,V)                -- dot product of two vectors

=====================
for Wilson etc:

M.colors
type(M)
M.lattice
V = M:vector(psi)
V = M * V
V = M(V)
V = V * a
V = a * V
V = V / a
V = -V
V = V + V
V = V - V
s = V.type
psi = V:value()
a = V:norm2()
a = dot(V,V)

====================== TODO
======================
======================
======================
Compositions of solvers and preconditioners
======================
Applying solvers to matrices and rhss

======================
Things that should be done differently in the long run:
* access to the MPI communicator of a lattice.
* access to gamma-matrix prepresentation.
* complex arithmetics.

====
* Access to solver parameters

