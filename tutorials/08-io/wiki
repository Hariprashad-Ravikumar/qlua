QLUA supports several popular QCD data formats. Not all formats are supported to the equal extend, in general QLUA can read more than it can write.

=NERSC gauge files=
Gauge fields written in the NERSC format (both precisions and all three major variants) could be read into QLUA. The reader function <code>qcd.nersc.read_gauge()</code> takes a file name and returns two values: the gauge field and the table constructed from the NERSC header. While reading it verifies the checksum and if there is a mismatch, reports an error and exist QLUA with an error status.

Here is a function that reads the NERSC file, prints all entries in the reader and returns the guage field:

 function load_nersc(file_name)
   local U, msg;
   U, msg = qcd.nersc.read_gauge(file_name)
   printf("HEADER of %q BEGIN\n", file_name)
   for i, v in pairs(msg) do
     printf("  %s = %s\n", i, tostring(v))
   end
   printf("END of %q HEADER\n", file_name)
   return U
 end

Notice, that QLUA converts some but not all header field values into numbers while leaving others as strings. Also, <code>qcd.nersc.read_gauge()</code> adds computed field <code>unitarity</code> to the header table. This field contains a measure of unitarity violation in the file. The following fields are always converted into numbers

{| class="wikitable"
|-
! field name
! meaning
|-
! DIMENSION_1
| lattice size in axis 0
|-
! DIMENSION_2
| lattice size in axis 1
|-
! DIMENSION_3
| lattice size in axis 2
|-
! DIMENSION_4
| lattice size in axis 3
|-
! CHECKSUM
| NERSC checksum of the data
|-
! PLAQUETTE
| average plaquette value (as stored in the header)
|-
! LINK_TRACE
| average link trace (as stored in the header)
|-
! unitarity
| not stored in the header, computed from the file data
|-
|}

The maximum unitarity violations tolerated by the reader are hardwired to 1e-6 for 32 bit files and 1e-12 for 64 bit files. Depending on the diligence of the NERSC file writers, they might need adjustment in the field.

=QDP/C++ QIO propagators=
QLUA also knows how to read propagators produced by Chroma in QDP/C++ QIO format. In addition to reading, QLUA can write propagators in this format.

The reader returns three values:
* The propagator. This is a regular QLUA <code>L:DiracPropagator</code> object.
* File info. A string read from the file, usually in XML.
* Record info. A string read from the file, usually in XML.

  fP, finfo, rinfo = qcd.qdpcc.read_prop("some-file")

You may use XML handling functions to extract information from <code>finfo</code> and <code>rinfo</code>.

If you need to write a file to be read later on by Chroma, use <code>qcd.qdpcc.write_prop()</code>. In this case you supply five arguments
* The file format. Use string <code>"F"</code> for 32 bit, and string <code>"D"</code> for 64 bit data.
* The file name to write.
* File level XML, a string. You may want to check with Chroma to see what it expects to find here.
* The propagator. Our good old QLUA <code>L:DiracPropagator</code> object
* Record level XML, a string. Again, check with Chroma to see what it expects here.

Below we write the same propagator in single and double precision.

  qcd.qdpcc.write_prop("F", "fp.32bit.qio", finfo, fP, rinfo)
  qcd.qdpcc.write_prop("D", "fp.64bit.qio", finfo, fP, rinfo)

=USQCD DD pairs propagators=
Another "standard" format is USQCD DD pairs. Agian, QLUA both reads and writes DD pairs files.
For the reader, one gives a file name and gets the source, the propagator, and the file info XML in return:

  source, prop, file_info = qcd.ddpairs.read("file.ddpairs")

Both the <code>source</code> and <code>prop</code> are <code>L:DiracPropagator</code> objects.

In order to write a DD pairs file, one needs to provide the following
* File format. <code>"F"</code> or <code>"D"</code> for writing 32bit and 64bit files respectively.
* File name.
* File info string. Many DD pair readers want to see a particular kind of XML here.
* Source field. It is a <code>L:DiracPropagator</code>.
* Source info string. Again, usually this is XML in a particular form.
* Source time slice alone the 3-rd axis. Only the value of the source field at this time slice is actually recorded in the file.
* Propagator field. This is also a <code>L:DiracPropagator</code>.
* Propagator info string. Once more, XML in a particular form.

Here we have a source at time slice 3:
 qcd.ddpairs.write("D", "test.DD", file_info,
                   src, "src info", 3,
                   prop, "prop info")

If the writer encounters and error, it will print an error messag to stderr and exit QLUA with an error status.

=QDP/C QIO files=
The main data format of QLUA is the QIO variant used by QDP/C. It allows one to keep more than one lattice field in a single file and provides interface for all lattice data types. To support mutpliple records properly, QLUA has reader and writer objects for QDP/C. Let us start with creating one reader and one writer.

  reader, rinfo = qcd.qdpc.Reader("input-file")
  out_xml = {["$tag"] = "test_output",
             {["$tag"] = "input",
              rinfo},
             {["$tag"] = "gauge_transform",
              "random"}}
  writer = qcd.qdpc.Writer("output-file", xml.unparse(out_xml))

We are going to assume that <code>reader</code> contains a Dirac fermion, a record we are going to skip, and a gauge field, and we will apply a random gauge transformation to the the gauge field and the fermion, and write the gauge transform, the gauge field, and the fermion field to the <code>writer</code>

First, let us create a random gauge transform:
  g = toSUn(L, 30*S:gaussian_ColorMatrix())

The first record in <code>reader</code> is a Dirac fermion:

  F, f_info = reader:DiracFermion()

If it is not, the <code>reader</code> will complain and exit. When the QDP/C reader reads a record, it uses the one and only lattice (which should be defined beforehand, of course).

Skip the next record:

  reader:skip()

Now, read the gauge field:

  U, u_info = reader:ColorMatrix(#L)

Now U is a gauge field and <code>u_info</code> is its record info. This time we read not one color matrix, but as many as there are dimensions on the lattice. Again, the reader checks that
the record is a gauge field for us.

At this point we no longer need the reader object. To conserve resources, let us close it. (At this point we promise to QLUA that we are not going to try to use the <code>reader</code> again. QLUA will remember this promise.)

  reader:close()

Just to be safe, we bind the name <code>reader</code> to the universal no-value next:

  reader = nil

Apply the gauge transformation to <code>F</code>:

  gF = g * F

And to each component of <code>U</code>. Remember how the gauge field transforms:

  gU = {}
  for i = 0, #L - 1 do
    gU[i+1] = g * U[i+1] * g:shift(i, "from_forward")
  end

Now we write <code>gU</code> and <code>gF</code>:

  writer:ColorMatrix(gU, u_info)
  writer:DiracFermion(gF, f_info)

If we were writing a real program, we would close the writer at this point. However, if this is not done, QLUA will eventually close the writer for us. (This is also true for the reader. The automatic closing happens only when QLUA can prove that we can not possibly ever use the object again. At that point all resources associated with the I/O object will be freed. Why did we bother closing the reader? Two reasons: first, to show how it is done, and second, to make QLUA free I/O resources at that time.)

== Generating input for the QDP/C IO test==
For reference, here is program used to generate <code>input-file</code>:
 require "stdlib"
 require "gauge"
 
 L = qcd.lattice{4,6,8}
 
 do
   local x = L:Int(0)
   for i = 0, #L - 1 do
     x = x * L[i] + L:pcoord(i)
   end
   S = L:RandomState(os.random(), L:Int(os.random()) + x)
 end
 
 U = {}
 for i = 0, #L - 1 do
   U[i+1] = toSUn(L, S:gaussian_ColorMatrix())
 end
 
 F = S:gaussian_DiracFermion()
 
 finfo = {["$tag"] = "test",
          "QDP/C test file (some funny characters: &<>\"\')"}
 
 w = qcd.qdpc.Writer("input-file", xml.unparse(finfo))
 
 w:DiracFermion(F, xml.unparse({["$tag"] = "fermion"}))
 w:RandomState(S, "")
 w:ColorMatrix(U, xml.unparse({["$tag"] = "gauge_field", "weak radnom"}))

Note, that one can put any characters through <code>xml.unparse()</code> -- it will convert them into proper XML for us.

== I/O methods==
There is a method for each lattice field type both in a writer and a reader. If the reader is called without an argument, a record containing one element of the specified type is expected. If the reader is given an argument, it must be an integer, as a vector of as many elements of the given type is expected.

In case of a writer, if the first argument is a lattice field, a record with one element of the specified type is written. Otherwise the first argument must be a table containing lattice fields of the same type. In this case a record containing that many elements will be written.

In the writer, the name of the method must match the type of the lattice field.
{| class="wikitable"
|-
|-
| I,str = reader:Int([i])
| writer:Int(I,str), writer:Int({I}, str)
|-
| S,str = reader:RandomState([i])
| writer:RandomState(S,str), writer:RandomState({S}, str)
|-
| R,str = reader:Real([i])
| writer:Real(R,str), writer:Real({R}, str)
|-
| C,str = reader:Complex([i])
| writer:Complex(C,str), writer:Complex({C}, str)
|-
| V,str = reader:ColorVector([i])
| writer:ColorVector(V,str), writer:ColorVector({V}, str)
|-
| M,str = reader:ColorMatrix([i])
| writer:ColorMatrix(S,str), writer:ColorMatrix({M}, str)
|-
| D,str = reader:DiracFermion([i])
| writer:DiracFermion(D,str), writer:DiracFermion({D}, str)
|-
| P,str = reader:DiracPropagator([i])
| writer:DiracPropagator(P,str), writer:DiracPropagator({P}, str)
|-
| reader:close()
| writer:close()
|-
| bool,str = reader:info()
|
|-
| bool = reader:skip()
|-
|}

The <code>reader:info()</code> returns <code>true</code> and the record info if there is a record at the current file position, and <code>nil</code> otherwise. In case of <code>reader:skip()</code> the return value if <code>true</code> if the record was successfully skipped. For both these functions QLUA does not terminate in case of error.
It appears that QDP prints an error message if there is a problem with either of the operations.

[[Category:Code]]
