In QCD we often need to apply computations only to a part of lattice. QLUA uses QDP/C mechanisms called subsets and multisets to this end, but exposes them somewhat differently to the user.
= Subsets=
By default, the whole lattice is used in computation, e.g.,
  x0 = L:pcoord(0)
binds <code>x1</code> to an integer field everywhere containing the value of the first coordinate.
Suppose we want to compute <code>x01</code> equal to the first coordinates on the even lattice sites and two the second coordinate on odd sites. Here is the code that does this:
  do                                 -- line 1
    x01 = L:pcoord(0)                -- line 2
    local function pc1(x)            -- line 3
      x:set(L:pcoord(1))             -- line 4
    end                              -- line 5
    L.odd:where(pc1, x01)            -- line 6
  end                                -- line 7
Let us go through this code snippet line by line.

On line 2 we set <code>x01</code> to the first coordinate ''everywhere''. 

Lines 3 to 5 define a procedure that sets its argument to the value of the
second coordinate on active sites.

On line 6 the magic happens. First we get the odd subset of the lattice, <code>L.odd</code>. Then its <code>:where()</code> method is called with two arguments, <code>pc1</code> and <code>x01</code>. The <code>:where()</code> changes the set of active sites on the lattice to the given subset and applies its first argument to the rest of arguments in this changed context. When the procedure returns, the active set is changed back to what it was before <code>:where()</code> was executed. 

The whole snippet is placed in a block in order to make <code>odd_pc1()</code> local to it. This is not striclty neccessary bus is a matter of style.

The lattice provides three default subsets:
* L.all is the whole lattice. It corresponds to <code>QDP_all</code>
* L.even is the even sublattice. It corresponds to <code>QDP_even</code>
* L.odd is the odd sublattice. It corresponds to <code>QDP_odd</code>

One can also construct hyperplane context for each of the lattice axes and positions. E.g.,
  L:Subset{axis=0, position=3}
is a subset consisting of points where the first coodrinate is equal to 3.
This could be used to create sources or restrict smearings. Here we create a wall source at time slice 10:
  src = L:DiracFermion()
  L:Subset{axis=3, position=10}:where(function()
      src:set(L:DiracFermion(L:Complex(complex(1,0)), {c=0, d=0}))
   end)

Like all other types, subsets are regular QLUA values. They could be bound to names, passed as arguments to functions and returned as function results.

= Multisets=
Multisets are closely related to subsets in QDP/C. When performing a sum across a lattice, it is often convenient to compute several sums across disjoined regions at the same time.

The sum reduction is defined as a method for <code>L:Int</code>, <code>L:Real</code>,
and <code>L:Complex</code> fields. If called without arguments, it collects contributions from the current active site set. If, however, it is given a lattice multiset as an argument, it will produce a vector of results.

Here is an illustration:
  require "stdlib"
  L = qcd.lattice{3,4,5}
  v = (L:Real(L:pcoord(0)) * 0.1):sin() +
      (L:Real(L:pcoord(1)) * 0.2):cos() +
      (L:Real(L:pcoord(2)) * 0.1):exp()
  s_all = v:sum()
  s_x = {}
  for i = 0, #L - 1 do
    s_x[i+1] = v:sum(L:MultiSet{d=i})
  end
  printf("full sum: %g\n\n", s_all)
  for i = 1, #L do
    printf("partial[%d] = %s\n", i, tostring(s_x[i]))
    local t = 0
    for x = 0, L[i-1] - 1 do
      printf("  [%d] = %g\n", x, s_x[i][x])
      t = t + s_x[i][x]
    end
    printf(" total %g\n\n", t)
  end

Just like subsets, multisets are regular QLUA values. They could be bound to names, passed as arguments, and returned from functions.

[[Category:Code]]
