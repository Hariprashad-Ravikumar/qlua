= How QLUA handles XML=
Here we make a small detour into handling of XML data.

QIO files often contain meta information in XML. QLUA provides three functions to facilitate dealing with XML data. Here's a summary of the behavior of these functions.

=Parsing XML=
If you have a string of XML, you could convert into a table form by calling <code>xml.parse()</code> on it:

 s = [=[<?xml version="1.0"?>
 <configuration>
   <creator>USQCD collaboration</creator>
   <ensemble>fake</ensemble>
   <serial>2790</serial>
   <action>
      <name>Clover</name>
      <kappa>0.1234</kappa>
      <c_sw>1.0</c_sw>
      <m_l>-0.001</m_l>
      <m_h>0.1</m_h>
   </action>
 </configuration>]=]
 x_s = xml.parse(s)

At this point <code>x_s</code> is a table with specially set structure. It could be further manipulated with <code>xml.get()</code>, included into other XML structures etc. (Here <code>[=[ ... ]=]</code> is LUA's way to write a long string.)

=Accessing XML elements=
Suppose we need to get the hopping parameter from <code>x_s</code> above. Here is how it is done in QLUA:

  k = xml.get(x_s, "action", "kappa", 1)
  printf("kappa=%s\n", k)

The last argument to <code>xml.get()</code> tells QLUA to strip the &lt;kappa&gt; tag and get the value. If you say

  k_tree = xml.get(x_s, "action", "kappa")
  printf("k_tree=%s\n", tostring(k_tree))

you will get the part of the parsed XML corresponding to &lt;kappa&gt;0.1234&lt;/kappa&gt;. This is useful if you want to draft a piece of XML into another XML string.

=Constructing XML tree=
The last function, <code>xml.unparse()</code> converts a table into an XML string. To make an interesting example, let us build a tree with the action subtree taken from <code>x_s</code> and some other parts invented completely for illustrative purposes.

  x_out = {["$tag"] = "output_example",
           {["$tag"] = "cg",
            kind = "mixed",
            {["$tag"] = "iterations", "2405"},
            {["$tag"] = "epsilon", string.format("%.10e", 9.761e-16)}},
            xml.get(x_s, "action") }
  
  s_out = xml.unparse(x_out)
  printf("s_out=%s\n", s_out)

Note that the parsed table may contain only subtrees and strings. Each table must contain a field called <code>"$tag"</code>, it will be used to construct the XML tags for the element.
Other named fields in the table will become XML element attributes.

If you put all the above pieces together and run QLUA on them, you would get output not unlike the following:

 kappa=0.1234
 k_tree=table: 0x4295b0
 s_out=<?xml version='1.0' ?>
 <output_example>
   <cg kind="mixed">
     <iterations>2405</iterations>
         <epsilon>9.7610000000e-16</epsilon>
   </cg>
   <action>
     <name>Clover</name>
     <kappa>0.1234</kappa>
     <c_sw>1.0</c_sw>
     <m_l>-0.001</m_l>
     <m_h>0.1</m_h>
   </action>
 </output_example>

=Implementation remarks=
The XML parser does not cover the whole version 1.0 of W3C specification. It is believed to be able to parse all existing QIO metadata, however.

[[Category:Code]]
