= Clover Level III library=
QLUA provides bindings to the Clover Level III library. Not all functionality implemented in the library is exposed, this could be easily extended if needed. The existing bindings are explained below in details.

= Creating a clover object=
The main entity provided is the clover object. It is implemented only for 4-d lattice and Nc=3. If this conditions are not met, the constructor reports and error and QLUA exists with an error code. The clover object is created from the following parameters
* The gauge field. As usual, a table of four Color Matrix. 
* The hopping parameter, κ. In the BMW conventions, κ=1/(8+2*m<sub>q</sub>)
* The clover coefficient, c<sub>sw</sub>.
* Boundary conditions. A table of four numbers defining factors picked up by the fermion field when crossing between L<sub>i</sub>-1 and 0. As all LUA tables, it is 1-based.
 
Once the clover object is created, <code>U</code> could be reused.

One can use multiple clover objects at the same time. Keep in mind, that each clover object takes a considerable amount of memory, though.

Here we create a Clover operator with Dirichlet boundary conditions in the T-direction:
  CL_dirichlet = qcd.Clover(U, 0.071, 1.002, {1, 1, 1, 0})
Another example: the standard antiperiodic in time, periodic in space operator:
  CL = qcd.Clover(U, 0.071, 1.0, {1, 1, 1, -1})

= Applying the Clover Operator=
With the clover object is constructed, one can apply both the Dirac operator and its conjugate.
  phi = CL:D(psi)  -- the Dirac Operator
  eta = CL:Dx(psi) -- the conjugated operator
If the argument given to <code>CL:D()</code> (or to <code>CL:Dx()</code>) is a DiracFermion field, the result will be also a DiracFermion field. If the arugment is a DiracPropagator, so will be the result.

= Solving the Dirac Equation=
To compute the inverse of the Dirac operator, one has to construct a solver first. Two kinds of solvers are provided.

The standard CG solver is created as follows:
   std_solver = CL:solver(1e-22, 10000)
Here the first argument is the require precision. The solver uses the red-black preconditioned normal equation, and stops when |Mx-b|<sup>2</sup>/|b|<sup>2</sup> < ε. The second argument is the maximum number of iterations CG could use. If the convergence is not reached within that limit, the solver will abort QLUA after printing and error message.

The second solver uses mixed single/double approach of the BMW group. You create the mixed solver by saying
    mx_solver = CL:mixed_solver(1e-10, 1000, 1e-22, 10000)
Here the first argument is precision to use in the single precision solver. The second argument set the maximal number of iterations in each single precision inverter. Next is the desired precision of the solver. Argument four sets the total number of iterations the solver may use before bailing out. The mixed solver still produces a double precision solution, but it may run faster than the standard solver. In particular, on the Blue Gene one can get about 30% speedup. On other platforms, the mixed solver could be at a disadvantage. One is advised to compare the solvers performance before embarking on a production calculation.

When applied to a fermion or a propagator, either solver will produce the solution to the Dirac equation. Here we solve the equation both ways and compute the true error:
   std_inv = std_solver(psi)
   mx_inv = mx_solver(psi)
   b2 = psi:norm2()
   std2 = (CL:D(std_inv) - psi):norm2()
   mx2 = (CL:D(mx_inv) - psi):norm2()
   printf("standard solver error: %.2e\n", std2/b2)
   printf("mixed solver error   : %.2e\n", mx2/b2)
The <code>:norm2()</code> method exists for every lattice field and compute the square of the norm accros the active lattice sites.

= Memory management=
The Dirac operators take considerable amount of memory. Though QLUA does proper memory management and reclaims this memory when the operator object is garbage collected, one may want to clean up earlier. The operator object has the <code>close()</code> method that frees all memory used by the operator object and marks the object against future use.
   CL:close()
After closing the operator object, one must not call any of its methods or solvers constructed from it. If one does, QLUA performs the usual catastrophic error shutdown.

[[Category:Code]]
