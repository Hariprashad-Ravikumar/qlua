=QLUA random number=
As we have already seen, in QLUA we can create a random generator suitable for filling lattice fields. There are two things of which one must beware, however:
* If true randomness is required, one should find somewhere a physical source of random bits.
* Care should be taken to initialize the generator into different states on each lattice site.

== Initializing serial random state==
Let us see how we can solve the first problem. A quick and dirty way is to type in a random sequence of digits after the equal sign into a file, e.g.:

   seed = 53467623

and give to to QLUA. There are certain problems with this approach, however. One is that human typing is biased. Another is that it is too easy to make a slip and reuse the seed file.

One solution to these problems is to be very disciplined and record 32 flips of a coin into each seed file you are going to use, and to be extra sure that you are never ever going to reuse a seed file.

QLUA provides another solution. If the platform supports <code>/dev/urandom</code>, QLUA binds a function to <code>os.random</code> that reads 32 bits out of the device and return them as QLUA's real. Here is a snippet of code that tests support of <code>/dev/urandom</code> in QLUA:

  require("stdlib")
  function true_random()
    if not os.random then
      eprintf("no /dev/urandom support")
      os.exit(1)
    end
    return os.random()
  end

Of course, instead of defining <code>true_random()</code>, one can simply call <code>os.random()</code>, and suffer a cryptic QLUA error message if the platform does not support <code>/dev/urandom</dev>.

== Lattice random state==
With a serial seed problem solved, let us construct a random state on a lattice. QLUA uses the random generator from QDP/C for its random state. For it, we need to provide a seed in two pieces:
* A serial integer
* A lattice integer
The random state combines them together and produces a random generator on each lattice site. It appears that if two sites have the same value of the lattice integer, their random states are identical.

Here's a simple initializer:

   function simple_random_state(L)
     local pv = L:Int(0)
     for i = 0, #L - 1 do
       pv = pv * L[i] + L:pcoord(i)
     end
     return L:RandomState(os.random(), pv)
   end

A better state could be produced with <code>pv</code> initialized to a random value instead of 0:

   function better_random_state(L)
     local pv = L:Int(os.random())
     for i = 0, #L - 1 do
       pv = pv * L[i] + L:pcoord(i)
     end
     return L:RandomState(os.random(), pv)
   end

== Using the random generator ==
There is a set of function to construct a random value of each lattice field supported by QLUA:

{| class="wikitable"
|-
| R = S:random_Real()
| uniform random in [0,1]
|-
| R = S:gaussian_Real()
| normally distributed real random
|-
| C = S:gaussian_Complex()
| normally distributed complex random
|-
| V = S:gaussian_ColorVector()
| normally distributed random color vector
|-
| M = S:gaussian_ColorMatrix()
| normally distributed random color matrix
|-
| D = S:gaussian_DiracFermion()
| normally distributed random Dirac fermion
|-
| P = S:gaussian_DiracPropagator()
| normally distributed random Dirac propagator
|-
|}

The gaussian generators produce values with the standard normal distribution. For lattice real fields, one can generate uniform randoms in [0,1] as well.

== Multiple random states==
It is possible to have more than one lattice random state in the program, e.g.,

   S1 = better_random_state(L)
   S2 = better_random_state(L)

Also, one can save the random state with

   Sx = L:RandomState(0, L:Int(0)) -- create a random state field 
   Sx.set(S) -- copy the current state of S into Sx

The first line here is needed because of the value semantics of LUA: one need to have a lattice random state field to apply the <code>:set()</code> method to. We do not care how it is initialized, hence using <code>(0, L:Int(0))</code> in the constructor.

Once copied, two random states are completely independent and produce identical streams of values.

   Sx = L:RandomState(0, L:Int(0)) -- create a random state field 
   Sx.set(S) -- copy the current state of S into Sx
   r1 = S:gaussian_Real()
   r2 = Sx:gaussian_Real()
   -- at this point r1 == r2 everywhere

[[Category:Code]]
