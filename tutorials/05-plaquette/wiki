= Computing the plaquette =
Now we have enough pieces to put together plaquette computation. Code pieces below make up a whole program that makes several gauge fields of varying randomness; for each of them we compute and print the plaquette value. The code pieces are interspersed with comments about the computation.

==Standard libraries==

  require("stdlib")

We need <code>printf()</code> and a few other functions commonly used in QCD code. We will discuss them where they are used.

In the real QCD application, one will also say <code>require("qcd")</code>, but in this tutorial we are dissecting most of them, so we do not require the canned routines.

== Lattice definition == 
To be able to run this tutorial on a laptop, let us keep the lattice size small:
  L = qcd.lattice{4,4,4,8}
  volume = 1
  for i = 0, #L - 1 do
    volume = volume * L[i]
  end

Lattice volume is a handy constant to have in the QCD code.

==Random State initialization==
  do
    local r = L:Int(os.random())
    for i = 0, #L - 1 do
      r = r * L[i] + L:pcoord(i)
    end
    S = L:RandomState(os.random(), r)
  end

Here <code>do ... end</code> block forms a lexical scope for local name <code>r</code>. Once the block is exited, <code>r</code> loses its binding. This is how LUA avoids name space pollution. We are not worried about reproducibility of the results, so we use true random numbers to initialize the lattice random state <code>S</code>.

==Making an SU(n) matrix==
In the following, we need to have an SU(3) matrix. One can easily construct one from an arbitrary matrix with the following function
  function toSUn(L, X)
    local Y = (X - X:adjoin()) / 2
    return (Y - Y:trace() / qcd.Nc * L:ColorMatrix(complex(1,0))):exp()
  end
Here we first define <code>Y</code> to be the antihermitian part of <code>X</code>, then project the result to traceless matrices (these two steps project <code>X</code> to the Lie algebra ''su(n)''), exponentiating the result gives us an element of the group.

Notice that we use <code>qcd.Nc</code> instead of writing 3 explicitly. It makes the code generic, so if QLUA is rebuilt with a different value of $Nc$, the procedure will still work.

==Weak SU(n) matrix==
Let us first make an random SU(n) matrix close to the group identity.
  function weak_SUn(L, S)
    return toSUn(L, 0.2 * S:gaussian_ColorMatrix())
  end
This code should be self-explanatory by now. If it is not, you may want to reread previous tutorials.

==Strong SU(n) matrix==
To make a more random SU(n) matrix we start with multiplying several random SU(n) matrices from the vicinity of the group identity and project the result back to the group for good measure. This approach allows us to avoid generating a random point with the correct Haar measure, while giving a reasonable approximation to the uniform distribution on the group manifold.

  function strong_SUn(L, S)
    local v = weak_SUn(L, S)
    for i = 1, 100 do
      v = v * weak_SUn(L, S)
    end
    return v:proj(1e-6, 150)
  end

The meaning of parameters of <code>v:proj()</code> is somewhat obscure. Please consult Chroma sources for their significance. QLUA tries to implement <code>:proj()</code> to be identical to the corresponding Chroma's routine.

==Computing plaquettes==
Computing the plaqutte in the ij plane is short but it deserves an explanation. First, the code

 function plaquette(U, i, j)
   local Ui = U[j+1]:shift(i, "from_forward")
   local Uj = U[i+1]:shift(j, "from_forward")
   local Pij = (U[i+1] * Ui * Uj:adjoin() * U[j+1]:adjoin()):trace():real()
 
   return Pij:sum() / (volume * qcd.Nc)
 end

* Here we struggle with two indexing schemes: LUA starts with 1, and QDP counts from 0. We prefer the zero-based approach, hence <code>U[j+1]</code> and <code>U[i+1]</code>.
* Definitions of <code>Ui</code> and <code>Uj</code> show how QLUA does nearest neighbor communication. Each lattice field has a method called <code>shift()</code> which takes two arguments: the shift axis (zero based), and the direction string. The direction string could be <code>"from_forward"</code>, <code>"from_backward"</code>, <code>"to_forward"</code>, or <code>"to_backward"</code>. There is no difference between <code>"from_forward"</code> and <code>"to_backward"</code>, they simply reflect different ways of looking on things.
* The definition of <code>Pij</code> shows that the string of multiplications produces a lattice object, to which one can apply the <code>trace()</code> method.
* Finally, <code>Pij:sum()</code> sums the plaquette value across the lattice. It is nice to have it normalized as shown.

==Running the plaquette code on a configuration==
One more routine. Here we compute all six plaquettes and print each of them as well as their average:

 function run_test(name, U)
   printf("plaquette test case: %s\n", name)
   local s = 0
   local k = 0
   for i in interval(0, #L-1) do
     for j in skip(i, interval(0, #L-1)) do
       local sij = plaquette(U, i, j)
       printf("  plaq[%d, %d] = %20.10f\n", i, j, sij)
       s = s + sij
       k = k + 1
     end
   end
   printf("average plaquette %20.10f\n\n", s / k);
 end

Interesting points:
* Once again, to make code as generic as possible, <code>k</code> here explicitly counts the number of 2-planes on the lattice.
* The loop over <code>i</code> is somewhat unusual. LUA calls constructs like these iterators. We have defined <code>interval(n,m)</code> in <code>stdlib</code> to return an iterator producing numbers <code>n</code>, <code>n+1</code>, ..., <code>m</code>.
* The loop over <code>j</code> uses another iterator constructor. Here <code>skip(n,x)</code> takes a number and an iterator and produces a new iterator that runs though all values produced by <code>x</code> skipping <code>n</code>. Using the a combination of <code>interval()</code> and <code>skip()</code> helps in making sums over subsets of directions. Function <code>bmw_hex()</code> in file <code>qlib/gauge.qlua</code> is an instructive example.
* Notice, that we compute the ij plaquette twice (once in i,j and once in j,i). This is done only to illustrate the use of the <code>skip()</code> iterator. In the real code one would avoid extra work by iterating <code>j</code> in <code>interval(i+1,#L-1)</code> instead.

==Tests==
Here are two test cases.
===Weak gauge field===
All plaquettes should be close to 1 in this case:

 W = {}
 for i = 0, #L - 1 do
   W[i+1] = weak_SUn(L, S)
 end
 run_test("weak field", W)

===More random gauge field===
Assuming the number of weak matrices used to construct a strong SU(n) matrix was large enough, all plaquettes should be close to 0 now:

 U = {}
 for i = 0, #L - 1 do
   U[i+1] = strong_SUn(L, S)
 end
 run_test("strong field", U)

[[Category:Code]]
